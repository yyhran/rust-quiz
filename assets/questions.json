[
  {
    "id": "001",
    "title": "macro-count-statements",
    "codeSnippet": "macro_rules! m {\n    ($($s:stmt)*) => {\n        $(\n            { stringify!($s); 1 }\n        )<<*\n    };\n}\n\nfn main() {\n    print!(\n        \"{}{}{}\",\n        m! { return || true },\n        m! { (return) || true },\n        m! { {return} || true },\n    );\n}\n",
    "currentIndex": 0,
    "difficulty": 3,
    "answer": "112",
    "explanation": "This question revolves around where the Rust grammar places statement\nboundaries.\n\nThe input rule of the macro `m!` is `$($s:stmt)*` which matches zero or more\nRust statements. The `$(`...`)*` part of the rule is a *repetition* which\nmatches the contents of the repetition zero or more times, and the `$s:stmt` is\na fragment specifier that matches a Rust statement (`stmt`) conforming to the\nrules of the Rust grammar. The matched statements are available within the\nexpanded code as the fragment variable `$s`.\n\nA *statement* is the top-level unit of syntax permitted within a function body.\nAll of the following are examples of statements. The grammar of function bodies\nrequires that some types of statements are followed by a semicolon, but the\nsemicolon is not part of the statement for the purpose of macro syntax.\n\n```rust\n// Items are statements.\nstruct S { x: u64 }\n\n// Let-bindings are statements.\nlet mut s = S { x: 1 }\n\n// Expressions are statements.\ns.x + 1\n```\n\nThe macro `m!` expands to zero or more copies of `{ stringify!($s); 1 }`\nseparated by the `<<` token. The `$(`...`)<<*` part of the rule is a repetition\nusing `<<` as the separator.\n\nUsing `<<` as a separator in a repetition in a macro is highly unusual. The most\ncommmonly used separator is the comma, written as `$(`...`),*`, but any other\nsingle token is allowed here. Crucially, `macro_rules!` treats all built-in Rust\noperators as single tokens, even those that consist of multiple characters like\n`<<`.\n\nThe `{ stringify!($s); 1 }` is an expression whose value is always 1. The value\nof `stringify!($s)` is discarded, so this is equivalent to the expression `{ 1\n}`. The reason for having `stringify!($s)` in there is to control the number of\ntimes the repetition is repeated, which is determined by which fragment\nvariables are used within the repetition. Writing a repetition without using any\nfragment variables inside of it would not be legal.\n\nSuppose we call this macro with three of the statements shown above as input.\n\n```rust\nm! {\n    struct S { x: u64 }\n    let mut s = S { x: 1 }\n    s.x + 1\n}\n```\n\nThe macro expands to:\n\n```rust\n{ stringify!(struct S { x: u64 }); 1 }\n    << { stringify!(let mut s = S { x: 1 }); 1 }\n    << { stringify!(s.x + 1); 1 }\n```\n\nEach of the `stringify`s expands to a string literal:\n\n```rust\n{ \"struct S { x: u64 }\"; 1 }\n    << { \"let mut s = S { x: 1 }\"; 1 }\n    << { \"s.x + 1\"; 1 }\n```\n\nThe values of the string literals are not used. In this case the expression is\nequivalent to `{ 1 } << { 1 } << { 1 }`, which is equivalent to `1 << 1 << 1`.\nThe `<<` operator is left-associative; the numeric value of this expression is\n4\\.\n\nAltogether, the relevant behavior of this macro is that it evaluates to `1 << 1\n<< 1 << ...` where the number of ones is equal to the number of Rust statements\nin the input of the macro. In closed form, the numeric value is `1 << (n - 1)`\nwhere `n` is the number of statements, except in the case that `n` is zero where\nthe macro expands to nothing and we get a syntax error at the call site.\n\nIt remains to determine how many statements are in the three invocations of\n`m!` in the quiz code.\n\n1. `return || true`\n\n    This is a return-expression that would return the closure `|| true`. It is\n    equivalent to `return (|| true)`. It is parsed as a single statement so the\n    `m!` invocation evaluates to `1`.\n\n2. `(return) || true`\n\n    This is a logical-OR expression. The `||` is a binary operator, where the\n    left-hand side is the expression `(return)` (of diverging type `!`) and the\n    right-hand side is the expression `true`. This expression is a single\n    statement so `m!` again evaluates to `1`.\n\n3. `{return} || true`\n\n    This one is two statements! A block-statement `{return}` followed by a\n    closure expression `|| true`.\n\n    The Rust grammar distinguishes between expressions that require a semicolon\n    in order to stand alone as a statement, and expressions that can be\n    statements even without a semicolon. Consider two examples:\n\n    ```rust\n    // No trailing semicolon required.\n    for t in vec {\n        /* ... */\n    }\n\n    // Trailing semicolon required.\n    self.skip_whitespace()?;\n    ```\n\n    The list of expression types that stand alone without a semicolon is defined\n    [here][classify] in libsyntax. The distinction informs a few different early\n    bail-out cases where the parser decides to finish parsing the current\n    expression.\n\n    Relevant to our case is that block expressions `{ /* ... */ }` terminate an\n    expression if doing so would be syntactically sensible. The parser does not\n    eagerly consume binary operators after a block expression. Thus one might\n    write:\n\n    ```rust\n    fn f() -> &'static &'static bool {\n        // Block expression.\n        {\n            println!(\"What a silly function.\");\n        }\n\n        // Reference to reference to true.\n        &&true\n    }\n    ```\n\n    In order to parse a block followed by a binary operator, we would need to\n    make it syntactically insensible for the parser to terminate an expression\n    at the close curly brace. This would usually be done by wrapping in\n    parentheses.\n\n    ```rust\n    fn f() -> bool {\n        ({ true } && true)\n    }\n    ```\n\n[classify]: https://github.com/rust-lang/rust/blob/1.30.1/src/libsyntax/parse/classify.rs#L17-L37\n\nAnyhow, the output of the program is `112`.",
    "hint": "The expression in the output of the macro evaluates to the same value as `1 <<\n(n - 1)` where `n` is the number of statements contained in the macro input."
  },
  {
    "id": "002",
    "title": "bitand-or-reference",
    "codeSnippet": "struct S(i32);\n\nimpl std::ops::BitAnd<S> for () {\n    type Output = ();\n\n    fn bitand(self, rhs: S) {\n        print!(\"{}\", rhs.0);\n    }\n}\n\nfn main() {\n    let f = || ( () & S(1) );\n    let g = || { () & S(2) };\n    let h = || ( {} & S(3) );\n    let i = || { {} & S(4) };\n    f();\n    g();\n    h();\n    i();\n}\n",
    "currentIndex": 0,
    "difficulty": 2,
    "answer": "123",
    "explanation": "The closures `f`, `g`, and `h` are all of type `impl Fn()`. The closure bodies\nare parsed as an invocation of the user-defined bitwise-AND operator defined\nabove by the `BitAnd` trait impl. When the closures are invoked, the bitwise-AND\nimplementation prints the content of the `S` from the right-hand side and\nevaluates to `()`.\n\nThe closure `i` is different. Formatting the code with rustfmt makes it clearer\nhow `i` is parsed.\n\n```rust\nlet i = || {\n    {}\n    &S(4)\n};\n```\n\nThe closure body consists of an empty block-statement `{}` followed by a\n*reference* to `S(4)`, not a bitwise-AND. The type of `i` is `impl Fn() ->\n&'static S`.\n\nThe parsing of this case is governed by [this code][classify] in libsyntax.\n\n[classify]: https://github.com/rust-lang/rust/blob/1.30.1/src/libsyntax/parse/classify.rs#L17-L37",
    "hint": "One of these four closures is unlike the other three."
  },
  {
    "id": "003",
    "title": "mutate-const",
    "codeSnippet": "struct S {\n    x: i32,\n}\n\nconst S: S = S { x: 2 };\n\nfn main() {\n    let v = &mut S;\n    v.x += 1;\n    S.x += 1;\n    print!(\"{}{}\", v.x, S.x);\n}\n",
    "currentIndex": 0,
    "difficulty": 1,
    "answer": "32",
    "explanation": "The semantics of `const` is that any mention of the `const` by name in\nexpression position is substituted with the value of the `const` initializer. In\nthis quiz code the behavior is equivalent to:\n\n```rust\nstruct S {\n    x: i32,\n}\n\nfn main() {\n    let v = &mut S { x: 2 };\n    v.x += 1;\n    S { x: 2 }.x += 1;\n    print!(\"{}{}\", v.x, S { x: 2 }.x);\n}\n```\n\nI have simply substituted every mention of `S` in expresson position with the\nvalue of `const S` which is `S { x: 2 }`.\n\nThe first line of `main` is equivalent to:\n\n```rust\nlet mut _tmp0 = S { x: 2 };\nlet v = &mut _tmp0;\n```\n\nThe second line of `main` mutates the value pointed to by `v`. The same value\nremains accessible through `v` for the rest of the lifetime of `v`, which is why\nthe first character printed is `3`.\n\nThe third line of `main` mutates a temporary that immediately goes out of scope\nat the semicolon. The second character printed is coming from a brand new `S {\nx: 2 }`, so `2` is printed.\n\nOne additional wrinkle in this code is the concept of namespaces and name\nresolution in Rust. Any name that refers to a *type* lives in the *type\nnamespace*, and any name that refers to a *value* lives in the *value\nnamespace*. These are two separate sets of names, and the language is structured\nsuch that we can always tell which namespace to look up a name in.\n\nIn the context of the quiz code, the name of the struct `S` is part of the type\nnamespace and the name of the const `S` is part of the value namespace. That is\nhow we can have seemingly two different things with the same name in scope at\nthe same time.",
    "hint": "In what ways is a `const` different from a non-mut `static`?"
  },
  {
    "id": "004",
    "title": "dotdot-in-tuple",
    "codeSnippet": "fn main() {\n    let (.., x, y) = (0, 1, ..);\n    print!(\"{}\", b\"066\"[y][x]);\n}\n",
    "currentIndex": 0,
    "difficulty": 1,
    "answer": "54",
    "explanation": "This question demonstrates two different meanings of `..`.\n\nIn expression position, `..` is the syntax for constructing various types of\nranges. Here the expression `(0, 1, ..)` is a tuple with three elements, the\nthird one having type [`RangeFull`].\n\n[`RangeFull`]: https://doc.rust-lang.org/std/ops/struct.RangeFull.html\n\nOn the other hand in a pattern, `..` is used to mean \"any number of elements\".\nSo the pattern `(.., x, y)` matches a tuple with 2 or more elements, binding the\nsecond-last one to `x` and the last one to `y`.\n\nComing out of the first line of `main`, we have `x = 1` and `y = (..)`. Thus the\nvalue printed is going to be `b\"066\"[..][1]`.\n\nThe expression `b\"066\"` is a byte-string literal of type `&'static [u8; 3]`\ncontaining the three ASCII bytes `b'0'`, `b'6'`, `b'6'`.\n\nWhen we slice the byte-string with `RangeFull` we get a dynamically sized slice\n`[u8]` of length 3. Next we access element `1` of the slice, which is the byte\n`b'6'` of type `u8`. When printed, we see the decimal representation of the byte\nvalue of the ASCII digit 6, which is the number 54.",
    "hint": "`..` means one thing in an expression and something else in a pattern."
  },
  {
    "id": "005",
    "title": "trait-resolution-hrtb",
    "codeSnippet": "trait Trait {\n    fn p(self);\n}\n\nimpl<T> Trait for fn(T) {\n    fn p(self) {\n        print!(\"1\");\n    }\n}\n\nimpl<T> Trait for fn(&T) {\n    fn p(self) {\n        print!(\"2\");\n    }\n}\n\nfn f(_: u8) {}\nfn g(_: &u8) {}\n\nfn main() {\n    let a: fn(_) = f;\n    let b: fn(_) = g;\n    let c: fn(&_) = g;\n    a.p();\n    b.p();\n    c.p();\n}\n",
    "currentIndex": 0,
    "difficulty": 0,
    "answer": "",
    "explanation": "",
    "hint": ""
  },
  {
    "id": "006",
    "title": "value-of-assignment",
    "codeSnippet": "use std::mem;\n\nfn main() {\n    let a;\n    let a = a = true;\n    print!(\"{}\", mem::size_of_val(&a));\n}\n",
    "currentIndex": 0,
    "difficulty": 1,
    "answer": "0",
    "explanation": "There are two variables named `a`, one shadowing the other. The program is\nequivalent to:\n\n```rust\nlet a;\nlet b = a = true;\nprint!(\"{}\", mem::size_of_val(&b));\n```\n\nFurther, the value being assigned to `b` is the expression `a = true`.\n\nIn Rust, assignment expressions always have the value `()`. Simplified some\nmore, the quiz code is equivalent to:\n\n```rust\nlet a = true;\nlet b = ();\nprint!(\"{}\", mem::size_of_val(&b));\n```\n\nRefer to the documentation of [`size_of_val`] for a specification of its\nbehavior, but in this case it is being instantiated with `T = ()` and we end up\nprinting the value of `size_of::<()>()`.\n\n[`size_of_val`]: https://doc.rust-lang.org/std/mem/fn.size_of_val.html\n\n`()` is one example of a [*zero-sized type*][zst] or ZST and is represented by\nzero bytes of data at runtime, so the program prints `0`.\n\n[zst]: https://doc.rust-lang.org/nomicon/exotic-sizes.html#zero-sized-types-zsts",
    "hint": "There are two variables named `a`. What is the type of each one?"
  },
  {
    "id": "007",
    "title": "surprise-wildcard-match",
    "codeSnippet": "#[repr(u8)]\nenum Enum {\n    First,\n    Second,\n}\n\nimpl Enum {\n    fn p(self) {\n        match self {\n            First => print!(\"1\"),\n            Second => print!(\"2\"),\n        }\n    }\n}\n\nfn main() {\n    Enum::p(unsafe {\n        std::mem::transmute(1u8)\n    });\n}\n",
    "currentIndex": 0,
    "difficulty": 0,
    "answer": "",
    "explanation": "",
    "hint": ""
  },
  {
    "id": "008",
    "title": "tokenize-punctuation",
    "codeSnippet": "macro_rules! m {\n    (==>) => { print!(\"1\"); };\n    (= = >) => { print!(\"2\"); };\n    (== >) => { print!(\"3\"); };\n    (= =>) => { print!(\"4\"); };\n}\n\nfn main() {\n    m!(==>);\n    m!(= = >);\n    m!(== >);\n    m!(= =>);\n}\n",
    "currentIndex": 0,
    "difficulty": 2,
    "answer": "1214",
    "explanation": "Adjacent punctuation characters in the input pattern of a `macro_rules!` macro\nare grouped according to how those characters are used by native Rust tokens.\n\n[This page][tokens] contains a list of the single-character and multi-character\npunctuation tokens involved in the Rust grammar.\n\n[tokens]: https://docs.rs/syn/0.15.22/syn/token/index.html#structs\n\nAs one example from that list, `<<=` is a single token because the Rust grammar\nuses that sequence of characters to mean [left shift assignment][ShlAssign].\nThus a `macro_rules!` input rule containing `<<=` would only match if all three\ncharacters `<<=` are written consecutively without spaces in the invocation.\n\n[ShlAssign]: https://doc.rust-lang.org/std/ops/trait.ShlAssign.html\n\nBut for example `=<<` is not a native token in the Rust grammar. The parser of\n`macro_rules!` will decompose this into Rust tokens according to a greedy\nprocess. `=<` is also not a native token, so first we would need to match a `=`\nby itself. Then `<<` *is* a native token. Writing `=<<` in a macro rule behaves\nexactly the same as writing `= <<`.\n\nNow let's decompose the rules in the quiz code the same way.\n\n- `==>` decomposes as `== >`.\n- `= = >` is already decomposed into Rust tokens.\n- `== >` is already decomposed.\n- `= =>` is already decomposed.\n\nOur macro is the same as if we had written the first rule with a space. The\nthird rule is unreachable.\n\n```rust\nmacro_rules! m {\n    (== >) => { print!(\"1\"); };\n    (= = >) => { print!(\"2\"); };\n    (== >) => { print!(\"3\"); };\n    (= =>) => { print!(\"4\"); };\n}\n```\n\nWithin `main`, the first and third lines *both* match the first macro rule. The\nsecond line matches the second rule and the fourth line matches the fourth rule.\nThe output is `1214`.\n\n[Procedural macros][syn] use a more flexible and powerful macro API and can\nalways distinguish between different spacings of the same characters, such as\n`== >` vs `==>`.\n\n[syn]: https://github.com/dtolnay/syn",
    "hint": "According to `macro_rules!`, `==` is one token and `=>` is one token."
  },
  {
    "id": "009",
    "title": "opaque-metavariable",
    "codeSnippet": "macro_rules! m {\n    (1) => { print!(\"1\") };\n    ($tt:tt) => { print!(\"2\") };\n}\n\nmacro_rules! e {\n    ($e:expr) => { m!($e) };\n}\n\nmacro_rules! t {\n    ($tt:tt) => { e!($tt); m!($tt); };\n}\n\nfn main() {\n    t!(1);\n}\n",
    "currentIndex": 0,
    "difficulty": 2,
    "answer": "21",
    "explanation": "This question involves the behavior of macro matchers as regards matching macro\nmetavariables.\n\nStarting from the bottom of the quiz code, the invocation `t!(1)` matches the\nfirst rule of `t!` and expands to `e!(1); m!(1);`.\n\nThe invocation `e!(1)` matches the first rule of `e!`. As part of this match,\nthe expression `1` is packaged into an opaque expression token called `$e`. At\nno subsequent point will it be possible for any `macro_rules!` macro to look\ninside of `$e`. All that can be known is that `$e` is *some* expression.\n\nIn any case, `e!(1)` expands to `m!($e)` where `$e` is an opaque expression\ncontaining `1`. That `m!($e)` *does not* match the first rule of `m!` because\n`$e` is opaque. Instead it matches the second rule of `m!` and prints `2`.\n\nAfter `e!(1)` there is an invocation `m!(1)` coming from the expansion of `t!`.\nThat one *does* match the first rule of `m!` and prints `1`. The output of this\nprogram is `21`.\n\nMost fragment specifiers have this behavior of becoming opaque token boxes, but\nsome do not. Specifiers that are opaque once matched:\n\n- `$:block`\n- `$:expr`\n- `$:item`\n- `$:literal`\n- `$:meta`\n- `$:pat`\n- `$:path`\n- `$:stmt`\n- `$:ty`\n\nThe rest of the specifiers do not become opaque and can be inspected by\nsubsequent rules:\n\n- `$:ident`\n- `$:lifetime`\n- `$:tt`\n\nFor example:\n\n```rust\nmacro_rules! m {\n    ('a) => {};\n}\n\nmacro_rules! l {\n    ($l:lifetime) => {\n        // $l is not opaque.\n        m!($l);\n    }\n}\n\nl!('a);\n```",
    "hint": "Upon being matched as a `$:expr`, the matched expression becomes a single opaque\ntoken tree."
  },
  {
    "id": "010",
    "title": "shadowed-trait-object-method",
    "codeSnippet": "trait Trait {\n    fn f(&self);\n}\n\nimpl<'a> dyn Trait + 'a {\n    fn f(&self) {\n        print!(\"1\");\n    }\n}\n\nimpl Trait for bool {\n    fn f(&self) {\n        print!(\"2\");\n    }\n}\n\nfn main() {\n    Trait::f(&true);\n    Trait::f(&true as &dyn Trait);\n    <_ as Trait>::f(&true);\n    <_ as Trait>::f(&true as &dyn Trait);\n    <bool as Trait>::f(&true);\n    <dyn Trait as Trait>::f(&true as &dyn Trait);\n}\n",
    "currentIndex": 0,
    "difficulty": 2,
    "answer": "222222",
    "explanation": "This question contains a trait method `Trait::f` as well as an inherent method\n`f` on the trait object type `dyn Trait`.\n\n*As far as I know,* given that these names shadow each other, the inherent\nmethod is literally uncallable. There is currently no syntax in Rust for calling\nthe inherent `f` on `dyn Trait`.\n\nOne additional syntax to try would be:\n\n```rust\n<dyn Trait>::f(&true);\n<dyn Trait>::f(&true as &dyn Trait);\n```\n\nIf the trait method were named something different, both of these would call the\ninherent method. If the inherent method were named something different, both of\nthese would call the trait method. But if the trait method and the inherent\nmethod are both `f` then the compiler reports an ambiguity.\n\n```\nerror[E0034]: multiple applicable items in scope\n  --> questions/010.rs:18:5\n   |\n18 |     <dyn Trait>::f(&true);\n   |     ^^^^^^^^^^^^^^ multiple `f` found\n   |\nnote: candidate #1 is defined in an impl for the type `dyn Trait`\n  --> questions/010.rs:6:5\n   |\n6  |     fn f(&self) {\n   |     ^^^^^^^^^^^\nnote: candidate #2 is defined in the trait `Trait`\n  --> questions/010.rs:2:5\n   |\n2  |     fn f(&self);\n   |     ^^^^^^^^^^^^\n   = help: to disambiguate the method call, write `Trait::f(...)` instead\n```\n\nMaybe some day it will be possible to disambiguate a call to an inherent method\non a trait object shadowed by a trait method. For now, the quiz code prints\n`222222`.",
    "hint": "This won't help you answer the question but may help feel better: the quiz\nauthor was also stumped by this one."
  },
  {
    "id": "011",
    "title": "function-pointer-comparison",
    "codeSnippet": "fn f<'a>() {}\nfn g<'a: 'a>() {}\n\nfn main() {\n    let pf = f::<'static> as fn();\n    let pg = g::<'static> as fn();\n    print!(\"{}\", (pf == pg) as u8);\n}\n",
    "currentIndex": 0,
    "difficulty": 3,
    "answer": "error",
    "explanation": "Function pointer comparison is generally a Bad Idea. It is easily possible to\nget nonsensical behavior in optimized builds. For a jaw-dropping example of such\nbehavior, check out [rust-lang/rust#54685] in which `x == y` is both true and\nnot true at the same time.\n\n[rust-lang/rust#54685]: https://github.com/rust-lang/rust/issues/54685\n\nThat said, the quiz code in this question fails to compile. Here is the compiler\noutput:\n\n```\nerror: cannot specify lifetime arguments explicitly if late bound lifetime parameters are present\n --> questions/011.rs:5:18\n  |\n5 |     let pf = f::<'static> as fn();\n  |                  ^^^^^^^\n  |\nnote: the late bound lifetime parameter is introduced here\n --> questions/011.rs:1:18\n  |\n1 | fn f<'a>() {}\n  |      ^^\n```\n\nGeneric parameters can be either early bound or late bound. Currently (and for\nthe foreseeable future) type parameters are always early bound, but lifetime\nparameters can be either early or late bound.\n\nEarly bound parameters are determined by the compiler during monomorphization.\nSince type parameters are always early bound, you cannot have a value whose\ntype has an unresolved type parameter. For example:\n\n```\nfn m<T>() {}\n\nfn main() {\n    let m1 = m::<u8>; // ok\n    let m2 = m; // error: cannot infer type for `T`\n}\n```\n\nHowever, this is often allowed for lifetime parameters:\n\n```\nfn m<'a>(_: &'a ()) {}\n\nfn main() {\n    let m1 = m; // ok even though 'a isn't provided\n}\n```\n\nSince the actual choice of lifetime `'a` depends on how it is called, we are\nallowed to omit the lifetime parameter and it will be determined at the call\nsite. The lifetime can even be different for each time it gets called.\n\nFor this reason, we cannot specify the lifetime on this function until it is\ncalled:\n\n```\n// error: cannot specify lifetime arguments explicitly if late bound lifetime parameters are present\nlet m2 = m::<'static>;\n```\n\nWe may not even ask the borrow checker to infer it too soon:\n\n```\n// error: cannot specify lifetime arguments explicitly if late bound lifetime parameters are present\nlet m3 = m::<'_>;\n```\n\nThe idea of late bound parameters overlaps considerably with a feature of Rust\ncalled \"higher ranked trait bounds\" (HRTB). This is a mechanism for expressing\nthat bounds on a trait's parameters are late bound. Currently this is limited to\nlifetime parameters, but the same idea exists in other languages (such as\nHaskell) for type parameters, which is where the term \"higher ranked\" comes\nfrom.\n\nThe syntax to express a HRTB for lifetimes uses the `for` keyword. To express\nthe type of `m1` above, we could have written:\n\n```\nlet m1: impl for<'r> Fn(&'r ()) = m;\n```\n\nYou can think of this as meaning: \"There is a lifetime but we don't need to\nknow what it is just yet\".\n\nLate bound lifetimes are always unbounded; there is no syntax for expressing a\nlate bound lifetime that must outlive some other lifetime.\n\n```\nerror: lifetime bounds cannot be used in this context\n --> src/main.rs:5:20\n  |\n5 |     let _: for<'b: 'a> fn(&'b ());\n  |                    ^^\n```\n\nLifetimes on _data types_ are always early bound except when the developer has\nexplicitly used the HRTB `for` syntax. On _functions_, lifetimes are late bound\nby default but can be early bound if:\n\n* The lifetime is declared outside the function signature, e.g. in an associated\n  method of a struct it could be from the struct itself; or\n\n* The lifetime parameter is bounded below by some other lifetime that it must\n  outlive. As we've seen, this constraint is not expressible in the HRTB that\n  would be involved in late binding the lifetime.\n\nBy these rules, the signature `fn f<'a>()` has a late bound lifetime parameter\nwhile the signature `fn g<'a: 'a>()` has an early bound lifetime parameter —\neven though the constraint here is ineffectual.\n\nOrdinarily these distinctions are compiler-internal terminology that Rust\nprogrammers are not intended to know about or think about in everyday code.\nThere are only a few edge cases where this aspect of the type system becomes\nobservable in the surface language, such as in the original quiz code.",
    "hint": "The way that `f` and `g` are written is not interchangeable."
  },
  {
    "id": "012",
    "title": "binding-drop-behavior",
    "codeSnippet": "struct D(u8);\n\nimpl Drop for D {\n    fn drop(&mut self) {\n        print!(\"{}\", self.0);\n    }\n}\n\nstruct S {\n    d: D,\n    x: u8,\n}\n\nfn main() {\n    let S { x, .. } = S {\n        d: D(1),\n        x: 2,\n    };\n    print!(\"{}\", x);\n\n    let S { ref x, .. } = S {\n        d: D(3),\n        x: 4,\n    };\n    print!(\"{}\", x);\n}\n",
    "currentIndex": 0,
    "difficulty": 1,
    "answer": "1243",
    "explanation": "This question involves drop-placement. Where does `D` get dropped?\n\nIn the first `let`-binding, we [destructure] a value of type `S` into its field\n`x` of type `u8` as well as `..` which represents \"the rest of `S`\". The part\nthat is the rest of `S` is dropped immediately at that point because it no\nlonger has an owner.\n\n[destructure]: https://doc.rust-lang.org/book/ch18-03-pattern-syntax.html#destructuring-to-break-apart-values\n\nIn the second `let`-binding, we borrow a field `x` from the owner of a value of\ntype `S`. The whole value of type `S` remains in scope during the time that its\nfield `x` is borrowed, and goes out of scope at the close curly brace of `main`.\n\nThe output is `1243`.",
    "hint": "The pattern `S { ref x, .. }` borrows a binding `x` from the owner of a value of\ntype `S`."
  },
  {
    "id": "013",
    "title": "mutable-zst",
    "codeSnippet": "struct S;\n\nfn main() {\n    let [x, y] = &mut [S, S];\n    let eq = x as *mut S == y as *mut S;\n    print!(\"{}\", eq as u8);\n}\n",
    "currentIndex": 0,
    "difficulty": 1,
    "answer": "1",
    "explanation": "In this code, `S` is a [zero sized type][zst] or ZST. Zero sized types are\ncompile-time concepts that disappear during compilation and have a runtime\nrepresentation of zero bytes.\n\n[zst]: https://doc.rust-lang.org/nomicon/exotic-sizes.html#zero-sized-types-zsts\n\nThe first line of `main` creates a local value of type `[S; 2]`. Let's refer to\nthat temporary as `tmp`. The `let`-binding binds two references into `tmp`, `x`\nreferring to `&mut tmp[0]` and `y` referring to `&mut tmp[1]`.\n\nOn the second line of `main` we want to know whether `x` and `y` as pointers\nhave the same value.\n\nThe array type `[S; 2]` is itself a zero sized type. You can confirm this by\nprinting the value of `std::mem::size_of::<[S; 2]>()`. Indeed the first and\nsecond element of the array have the same memory address.\n\nOrdinarily having multiple mutable references to the same memory location would\nnot be safe, but in the case of mutable references to zero sized types,\ndereferencing is a no-op so there is no way to violate any memory safety\nguarantees this way.",
    "hint": "Is it okay for two mutable references to point to the same memory location? What\ncould go wrong?"
  },
  {
    "id": "014",
    "title": "trait-autoref",
    "codeSnippet": "trait Trait: Sized {\n    fn is_reference(self) -> bool;\n}\n\nimpl<'a, T> Trait for &'a T {\n    fn is_reference(self) -> bool {\n        true\n    }\n}\n\nfn main() {\n    match 0.is_reference() {\n        true => print!(\"1\"),\n        false => print!(\"0\"),\n    }\n\n    match '?'.is_reference() {\n        true => print!(\"1\"),\n        false => {\n            impl Trait for char {\n                fn is_reference(self) -> bool {\n                    false\n                }\n            }\n            print!(\"0\")\n        }\n    }\n}\n",
    "currentIndex": 0,
    "difficulty": 1,
    "answer": "10",
    "explanation": "Trait impls anywhere in a program are always in scope, so there is no\nsignificance to the `impl Trait for char` being written inside of a block of\ncode. In particular, that impl is visible throughout the whole program, not just\nwithin the block containing the impl.\n\nThis question relates to the behavior of trait method auto-ref which is covered\nin [this Stack Overflow answer][SO].\n\n[SO]: https://stackoverflow.com/a/28552082/6086311\n\nThe call to `0.is_reference()` observes that there is no implementation of\n`Trait` for an integer type that we could call directly. Method resolution\ninserts an auto-ref, effectively evaluating `(&0).is_reference()`. This time the\ncall matches `impl<'a, T> Trait for &'a T` and prints `1`.\n\nThe call to `'?'.is_reference()` instead finds `impl Trait for char`, printing\n`0`.",
    "hint": "Trait method auto-ref is covered in [this Stack Overflow answer][SO].\n\n[SO]: https://stackoverflow.com/a/28552082/6086311"
  },
  {
    "id": "015",
    "title": "inference-of-number-type",
    "codeSnippet": "trait Trait {\n    fn f(&self);\n}\n\nimpl Trait for u32 {\n    fn f(&self) {\n        print!(\"1\");\n    }\n}\n\nimpl<'a> Trait for &'a i32 {\n    fn f(&self) {\n        print!(\"2\");\n    }\n}\n\nfn main() {\n    let x = &0;\n    x.f();\n}\n",
    "currentIndex": 0,
    "difficulty": 1,
    "answer": "1",
    "explanation": "During type inference the variable `x` has type `&{integer}`, a reference to\nsome as yet undetermined integer type.\n\nIf we want to resolve the trait method call `Trait::f(x)`, we find that its\nargument `x` must be of type `&Self` for some type `Self` that implements\n`Trait`. We find that inferring `0: u32` satisfies both the constraint that\n`u32` is an integer as well as `u32` implements `Trait`, so the method call ends\nup calling `<u32 as Trait>::f(x)` and prints `1`.\n\nTrait method resolution is covered in more detail in [this Stack Overflow\nanswer][SO].\n\n[SO]: https://stackoverflow.com/a/28552082/6086311",
    "hint": "What type would type inference infer for `x`?"
  },
  {
    "id": "016",
    "title": "prefix-decrement",
    "codeSnippet": "fn main() {\n    let mut x = 4;\n    --x;\n    print!(\"{}{}\", --x, --x);\n}\n",
    "currentIndex": 0,
    "difficulty": 1,
    "answer": "44",
    "explanation": "Unlike C or Java, there is no unary increment or decrement operator in Rust. The\nRust language design FAQ (no longer available online) used to touch on the\nreason:\n\n> **Why doesn't Rust have increment and decrement operators?**<br>\n> Preincrement and postincrement (and the decrement equivalents), while\n> convenient, are also fairly complex. They require knowledge of evaluation\n> order, and often lead to subtle bugs and undefined behavior in C and C++. `x =\n> x + 1` or `x += 1` is only slightly longer, but unambiguous.\n\nIn the absence of a decrement operator, `--x` is parsed as `-(-x)`. In the case\nof `x = 4` this would be `-(-4)` which is `4`. The program is equivalent to:\n\n```rust\nfn main() {\n    let mut x = 4;\n    4;\n    print!(\"{}{}\", 4, 4);\n}\n```",
    "hint": "The set of operators supported by Rust is documented in [`std::ops`].\n\n[`std::ops`]: https://doc.rust-lang.org/std/ops/index.html"
  },
  {
    "id": "017",
    "title": "unary-decrement",
    "codeSnippet": "fn main() {\n    let mut a = 5;\n    let mut b = 3;\n    print!(\"{}\", a-- - --b);\n}\n",
    "currentIndex": 0,
    "difficulty": 1,
    "answer": "2",
    "explanation": "Unlike C or Java, there is no unary increment or decrement operator in Rust. The\nRust language design FAQ (no longer available online) used to touch on the\nreason:\n\n> **Why doesn't Rust have increment and decrement operators?**<br>\n> Preincrement and postincrement (and the decrement equivalents), while\n> convenient, are also fairly complex. They require knowledge of evaluation\n> order, and often lead to subtle bugs and undefined behavior in C and C++. `x =\n> x + 1` or `x += 1` is only slightly longer, but unambiguous.\n\nIn the absence of postfix and prefix decrement operators, `a-- - --b` is parsed\nas `a - (-(-(-(-b))))`. In the case of `a = 5` and `b = 3` the value of this\nexpression is `5 - 3` which is `2`.",
    "hint": "The set of operators supported by Rust is documented in [`std::ops`].\n\n[`std::ops`]: https://doc.rust-lang.org/std/ops/index.html"
  },
  {
    "id": "018",
    "title": "method-or-function-pointer",
    "codeSnippet": "struct S {\n    f: fn(),\n}\n\nimpl S {\n    fn f(&self) {\n        print!(\"1\");\n    }\n}\n\nfn main() {\n    let print2 = || print!(\"2\");\n    S { f: print2 }.f();\n}\n",
    "currentIndex": 0,
    "difficulty": 1,
    "answer": "1",
    "explanation": "A call that looks like `.f()` always resolves to a method, in this case the\ninherent method `S::f`. If there were no method `f` in scope, a call like this\nwould fail to compile even if a field `f` exists and contains a function\npointer.\n\nTo call the function pointer stored in field `f`, we would need to write\nparentheses around the field access:\n\n```rust\nfn main() {\n    let print2 = || print!(\"2\");\n    (S { f: print2 }.f)();\n}\n```",
    "hint": "The call `.f()` resolves to either the field `f` or the inherent method `f`. How\nwould you write a call to the other one?"
  },
  {
    "id": "019",
    "title": "dropped-by-underscore",
    "codeSnippet": "struct S;\n\nimpl Drop for S {\n    fn drop(&mut self) {\n        print!(\"1\");\n    }\n}\n\nfn main() {\n    let s = S;\n    let _ = s;\n    print!(\"2\");\n}\n",
    "currentIndex": 0,
    "difficulty": 1,
    "answer": "21",
    "explanation": "The relevant line is `let _ = s`. If this line does not move `s` then `s` will\ncontinue to live until the close curly brace and the program would print `21`.\nBut if this line does move `s`, without binding it, then the moved value of type\n`S` would be dropped immediately and the program would print `12`.\n\nIn fact `s` does not get moved and the output is `21`.",
    "hint": "Does `s` get moved?"
  },
  {
    "id": "020",
    "title": "break-return-in-condition",
    "codeSnippet": "fn return1() {\n    if (return { print!(\"1\") }) {\n    }\n}\n\nfn return2() {\n    if return { print!(\"2\") } {\n    }\n}\n\nfn break1() {\n    loop {\n        if (break { print!(\"1\") }) {\n        }\n    }\n}\n\nfn break2() {\n    loop {\n        if break { print!(\"2\") } {\n        }\n    }\n}\n\nfn main() {\n    return1();\n    return2();\n    break1();\n    break2();\n}\n",
    "currentIndex": 0,
    "difficulty": 2,
    "answer": "121",
    "explanation": "Let's work through the functions one at a time.\n\n- `fn return1`\n\n    The condition of the `if`-statement is parsed as a return-expression that\n    returns the value `{ print!(\"1\") }` of type `()`. The value needs to be\n    evaluated prior to being returned so this function prints `1`.\n\n- `fn return2`\n\n    This function is parsed the same as `return1`. The `return` keyword eagerly\n    consumes a trailing return value, even if the return value begins with a\n    curly brace, and even in the condition of an `if`-statement where curly\n    braces such as in a struct literal would ordinarly not be accepted. This\n    function prints `2`.\n\n- `fn break1`\n\n    The condition of the `if`-statement is a break-with-value expression that\n    breaks out of the enclosing loop with the value `{ print!(\"1\") }` of type\n    `()`. Similar to `return1`, in order to break with this value the value\n    needs to be evaluated and this function prints `1`.\n\n- `fn break2`\n\n    Here we observe a difference between the grammar of `break` and the grammar\n    of `return`. Unlike `return`, the `break` keyword in the condition of this\n    `if`-statement *does not* eagerly parse a value that begins with a curly\n    brace. This code is parsed as:\n\n    ```rust\n    loop {\n        if break {\n            print!(\"2\")\n        }\n        {}\n    }\n    ```\n\n    We break out of the loop before executing the print, so this function does\n    not print anything.\n\n    I believe the reason for the difference between `return` and `break` is that\n    returning a value was obviously supported at Rust 1.0 and well before, but\n    break-with-value was introduced fairly late, in [Rust 1.19]. The code in\n    `break2` was perfectly legal Rust code prior to Rust 1.19 so we cannot\n    change its behavior when implementing the break-with-value language feature.\n\n    It is possible that a future Edition would adjust the two grammars to align\n    with each other.\n\n[Rust 1.19]: https://blog.rust-lang.org/2017/07/20/Rust-1.19.html\n\nThe output from `main` is `121`.",
    "hint": "The Rust grammar involving `break` is different from the grammar involving\n`return`."
  },
  {
    "id": "021",
    "title": "closure-or-logical-or",
    "codeSnippet": "trait Trait {\n    fn f(&self);\n}\n\nimpl<F: FnOnce() -> bool> Trait for F {\n    fn f(&self) {\n        print!(\"1\");\n    }\n}\n\nimpl Trait for () {\n    fn f(&self) {\n        print!(\"2\");\n    }\n}\n\nfn main() {\n    let x = || { (return) || true; };\n    x().f();\n\n    let x = loop { (break) || true; };\n    x.f();\n\n    let x = || { return (|| true); };\n    x().f();\n\n    let x = loop { break (|| true); };\n    x.f();\n\n    let x = || { return || true; };\n    x().f();\n\n    let x = loop { break || true; };\n    x.f();\n}\n",
    "currentIndex": 0,
    "difficulty": 2,
    "answer": "221111",
    "explanation": "We want to know whether each possible parenthesization of `return || true;` and\n`break || true;` evaluates to the closure `|| true` or to the unit value `()`.\n\n- `let x = || { (return) || true; };`\n\n    On this line, `x` is a closure that returns `()`. It is equivalent to `let x\n    = || {}`. When we call `x().f()`, the method `f` resolves to `impl Trait for\n    ()` which prints `2`.\n\n    The type of the *expression* `(return)` is the primitive [never] type,\n    usually written as `!`. It is legal to compute `! || true` because `!` can\n    fill in for any type, in this case bool. The expression `! || true` is a\n    logical-OR with bool on both the left-hand side and right-hand side.\n\n    The behavior of `!` of filling in for any type is what allows us to write:\n\n    ```rust\n    fn f() -> bool {\n        unimplemented!()\n    }\n    ```\n\n    in which the type of `unimplemented!()`, since it panics without evaluating\n    to any value, is also `!`.\n\n    [never]: https://doc.rust-lang.org/std/primitive.never.html\n\n- `let x = loop { (break) || true; };`\n\n    Similar to `(return)`, the type of `(break)` is the never type `!`. This\n    code breaks out of the loop with the implicit value `()`, so `x` is of type\n    `()`. Calling `x.f()` will print `2`.\n\n- `let x = || { return (|| true); };`\n\n    On this line `x` is a closure that returns a closure that returns `true`.\n    You could write `x()()` and that would be `true`.\n\n    The quiz code calls `x().f()` which resolves to `impl<F> Trait for F where\n    F: FnOnce() -> bool`. That trait impl prints `1`.\n\n- `let x = loop { break (|| true); };`\n\n    This is a loop containing a break-with-value expression. The argument of the\n    `break` becomes the value of the enclosing `loop`. This code is equivalent\n    to `let x = || true`.\n\n    When we call `x.f()` it uses the `FnOnce` impl of `Trait` which prints `1`.\n\n- `let x = || { return || true; };`\n\n    Now we arrive at the meat of this quiz question. Is `return || true` parsed\n    the same as `(return) || true` or as `return (|| true)`?\n\n    It turns out to be the latter, so `x` is a closure that returns a closure\n    that returns true. `x().f()` prints `1`.\n\n- `let x = loop { break || true; };`\n\n    Similar question here, is this `(break) || true` or `break (|| true)`?\n\n    The break-with-value language feature was added to Rust more than two years\n    after 1.0, in [Rust 1.19]. Prior to break-with-value, `break || true` was\n    perfectly legal Rust code that parsed as `(break) || true`.\n\n    In Rust 1.19 the behavior of this code was unintentionally broken by the\n    language such that now it parses as `break (|| true)` and the printed value\n    is `1`.\n\n    If we had noticed this change in meaning during the development of Rust\n    1.19, we may have adjusted the parsing to preserve the meaning of existing\n    code. Unfortunately doing so would result in a grammar that behaves\n    differently between `return` and `break` for no justifiable reason other\n    than an accident of history.\n\n    Or it is possible we would have ruled this an edge case of syntax that would\n    never appear in real code, used [Crater] to validate that hypothesis, and\n    broken the behavior intentionally.\n\n[Rust 1.19]: https://blog.rust-lang.org/2017/07/20/Rust-1.19.html\n[Crater]: https://github.com/rust-lang-nursery/crater\n\nThe total output from `main` is `221111`.",
    "hint": "The `break` and `return` keywords have the same grammar in this question."
  },
  {
    "id": "022",
    "title": "macro-tokenize-number",
    "codeSnippet": "macro_rules! m {\n    ($a:tt) => { print!(\"1\") };\n    ($a:tt $b:tt) => { print!(\"2\") };\n    ($a:tt $b:tt $c:tt) => { print!(\"3\") };\n    ($a:tt $b:tt $c:tt $d:tt) => { print!(\"4\") };\n    ($a:tt $b:tt $c:tt $d:tt $e:tt) => { print!(\"5\") };\n    ($a:tt $b:tt $c:tt $d:tt $e:tt $f:tt) => { print!(\"6\") };\n    ($a:tt $b:tt $c:tt $d:tt $e:tt $f:tt $g:tt) => { print!(\"7\") };\n}\n\nfn main() {\n    m!(-1);\n    m!(-1.);\n    m!(-1.0);\n    m!(-1.0e1);\n    m!(-1.0e-1);\n}\n",
    "currentIndex": 0,
    "difficulty": 1,
    "answer": "22222",
    "explanation": "All five invocations of `m!` pass two tokens as input: a minus sign followed by\nan integer or floating point literal token.\n\nThe floating point literals `1.`, `1.0`, `1.0e1`, `1.0e-1` are each a single\natomic token.\n\nThe parser built into the Rust compiler always parses a negative sign as a\nseparate token from the numeric literal that is being negating. However, it is\npossible for a user-defined parser within a [procedural macro] to construct a\nnegative number as a single token by passing a negative integer or negative\nfloating point value to one of the constructors of [`proc_macro::Literal`]. If\nsuch a negative literal ends up in the input of a subsequent procedural macro\ninvocation, it is up to the compiler whether to rewrite into a pair of tokens or\nkeep them as one.\n\n[procedural macro]: https://github.com/dtolnay/syn\n[`proc_macro::Literal`]: https://doc.rust-lang.org/proc_macro/struct.Literal.html\n\nThe behavior of the compiler's parser is observable in the surface language as\nwell, not only in macros. For example the following code prints `-81` because\nthe expression is parsed as `-(3i32.pow(4))` rather than `(-3i32).pow(4)`.\n\n```rust\nfn main() {\n    let n = -3i32.pow(4);\n    println!(\"{}\", n);\n}\n```",
    "hint": "The macro is counting how many \"tokens\" are in its input."
  },
  {
    "id": "023",
    "title": "inherent-vs-trait-method",
    "codeSnippet": "trait Trait {\n    fn f(&self);\n    fn g(&self);\n}\n\nstruct S;\n\nimpl S {\n    fn f(&self) {\n        print!(\"1\");\n    }\n\n    fn g(&mut self) {\n        print!(\"1\");\n    }\n}\n\nimpl Trait for S {\n    fn f(&self) {\n        print!(\"2\");\n    }\n\n    fn g(&self) {\n        print!(\"2\");\n    }\n}\n\nfn main() {\n    S.f();\n    S.g();\n}\n",
    "currentIndex": 0,
    "difficulty": 2,
    "answer": "12",
    "explanation": "`S.f()` calls the inherent method `f`. If an inherent method and a trait method\nhave the same name and receiver type, plain method call syntax will always\nprefer the inherent method. The caller would need to write `Trait::f(&S)` or `<S\nas Trait>::f(&S)` in order to call the trait method.\n\nIt is important for macro authors to be aware of this. Macro-generated code\ntypically should not use method call syntax to invoke trait methods on types\ndefined by the user. Those calls could get unintentionally hijacked by inherent\nmethods having the same name as the trait method.\n\nOn the other hand, `S.g()` calls the trait method `g`. Auto-ref during method\nresolution always prefers making something into `&` over making it into `&mut`\nwhere either one would work.\n\nSee [this Stack Overflow answer][SO] for a more detailed explanation of auto-ref\nduring method resolution.\n\n[SO]: https://stackoverflow.com/a/28552082/6086311",
    "hint": "I can't help you with this one. This is a pretty arbitrary choice made by the\nlanguage. Try all the possibilities!"
  },
  {
    "id": "024",
    "title": "local-and-const-hygiene",
    "codeSnippet": "fn main() {\n    let x: u8 = 1;\n    const K: u8 = 2;\n\n    macro_rules! m {\n        () => {\n            print!(\"{}{}\", x, K);\n        };\n    }\n\n    {\n        let x: u8 = 3;\n        const K: u8 = 4;\n\n        m!();\n    }\n}\n",
    "currentIndex": 0,
    "difficulty": 1,
    "answer": "14",
    "explanation": "This program prints `14` because hygiene in `macro_rules!` only applies to local\nvariables.\n\nYou can imagine hygiene as a way of assigning a color to each mention of the\nname of a local variable, allowing for there to be multiple distinguishable\nlocal variables in scope simultaneously with the same name.\n\nAt the top of `main`, suppose we consider the name of the local variable `x` to\nbe a purple `x`. The name of the constant `K` is just plain `K`, as constants\nare considered items rather than local variables (you can place items outside of\na function body; you cannot place local variables outside of a function body).\n\n<pre><code>let <b style=\"background-color:mediumpurple;color:white\">x</b>: u8 = 1;\nconst <b>K</b>: u8 = 2;</code></pre>\n\nContinuing down the body of `main`, within the declaration of the macro `m!`\nthere are identifiers `x` and `K` being used. Since there is a local variable\n`x` in scope, the use of the identifier `x` within the macro body picks up the\nsame color as the local variable `x`. There is no local variable `K` in scope so\nthe `K` within the declaration of the macro is assigned some new color, say\norange.\n\n<pre><code>macro_rules! m {\n    () => {\n        print!(\"{}{}\", <b style=\"background-color:mediumpurple;color:white\">x</b>, <b style=\"background-color:coral;color:white\">K</b>);\n    };\n}</code></pre>\n\nNext we enter a new scope (delimited by curly braces) containing another `x` and\n`K`. Every new local variable always introduces a new color so let's call this\n`x` blue. The const again is not a local variable so no color is assigned to\n`K`.\n\n<pre><code>{\n    let <b style=\"background-color:dodgerblue;color:white\">x</b>: u8 = 3;\n    const <b>K</b>: u8 = 4;\n\n    m!();\n}</code></pre>\n\nWhen `m!()` expands, the expanded code refers to a purple `x` and an orange `K`.\nThe purple `x` is distinguishable from the blue `x` -- the value of the purple\n`x` is printed which is `1`. As for the `K`, an unhygienic (uncolored) `K` is\nallowed to act like any color. The second `K` is shadowing the first one. It\ngets picked up when looking for an orange `K` and its value is printed, which is\n`4`.\n\nSo the output of the quiz code is `14`.",
    "hint": "Hygiene in `macro_rules!` only applies to local variables."
  },
  {
    "id": "025",
    "title": "unit-infallible-match",
    "codeSnippet": "use std::fmt::{self, Display};\n\nstruct S;\n\nimpl Display for S {\n    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n        formatter.write_str(\"1\")\n    }\n}\n\nimpl Drop for S {\n    fn drop(&mut self) {\n        print!(\"2\");\n    }\n}\n\nfn f() -> S {\n    S\n}\n\nfn main() {\n    let S = f();\n    print!(\"{}\", S);\n}\n",
    "currentIndex": 0,
    "difficulty": 1,
    "answer": "212",
    "explanation": "This program prints `212`.\n\nNo value of type `S` gets dropped within the body of function `f`. The function\n`f` conjures an `S` and returns ownership of it to the caller of `f`; the caller\ndetermines when to drop the `S` of which it received ownership.\n\nOn the first line of `main`, we call `f()` and perform an infallible match that\nbinds no new variables. As no variables are declared on this line, there is no\nvariable that could be the owner of the `S` returned by `f()` so that `S` is\ndropped at that point, printing `2`. The `S` in `let S = f()` is a unit struct\npattern (not a variable name) that matches a value of type `S` via\n[destructuring] but does not bind the value to any variable.\n\n[destructuring]: https://doc.rust-lang.org/book/ch18-03-pattern-syntax.html#destructuring-to-break-apart-values\n\nThe second line of `main` conjures a new `S`, prints it, and drops it at the\nsemicolon.",
    "hint": "Figure out what values are owned by which variables where. A value is dropped\nwhen it no longer has an owner."
  },
  {
    "id": "026",
    "title": "iterator-lazy-map",
    "codeSnippet": "fn main() {\n    let input = vec![1, 2, 3];\n\n    let parity = input\n        .iter()\n        .map(|x| {\n            print!(\"{}\", x);\n            x % 2\n        });\n\n    for p in parity {\n        print!(\"{}\", p);\n    }\n}\n",
    "currentIndex": 0,
    "difficulty": 1,
    "answer": "112031",
    "explanation": "As described in the documentation of the [`Iterator::map`] method, the map\noperation is performed lazily. The closure provided as an argument to `map` is\nonly invoked as values are consumed from the resulting iterator. The closure is\nnot applied eagerly to the entire input stream up front.\n\n[`Iterator::map`]: https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.map\n\nIn this code, the `for` loop is what drives the iteration. For each element\nconsumed from the `parity` iterator, our closure needs to be evaluated one time.\nThus the output will alternate between numbers printed by the closure and\nnumbers printed by the loop body.",
    "hint": "Refer to the documentation of the [`Iterator`] trait.\n\n[`Iterator`]: https://doc.rust-lang.org/std/iter/trait.Iterator.html"
  },
  {
    "id": "027",
    "title": "subtrait-dispatch",
    "codeSnippet": "trait Base {\n    fn method(&self) {\n        print!(\"1\");\n    }\n}\n\ntrait Derived: Base {\n    fn method(&self) {\n        print!(\"2\");\n    }\n}\n\nstruct BothTraits;\nimpl Base for BothTraits {}\nimpl Derived for BothTraits {}\n\nfn dynamic_dispatch(x: &dyn Base) {\n    x.method();\n}\n\nfn static_dispatch<T: Base>(x: T) {\n    x.method();\n}\n\nfn main() {\n    dynamic_dispatch(&BothTraits);\n    static_dispatch(BothTraits);\n}\n",
    "currentIndex": 0,
    "difficulty": 1,
    "answer": "11",
    "explanation": "The two traits `Base` and `Derived` each define a trait method called `method`.\nThese methods happen to have the same name but are otherwise unrelated methods\nas explained below.\n\nBoth traits provide a default implementation of their trait method. Default\nimplementations are conceptually copied into each trait impl that does not\nexplicitly define the same method. In this case for example `impl Base for\nBothTraits` does not provide its own implementation of `Base::method`, which\nmeans the implementation of `Base` for `BothTraits` will use the default\nbehavior defined by the trait i.e. `print!(\"1\")`.\n\nAdditionally, `Derived` has `Base` as a _supertrait_ which means that every type\nthat implements `Derived` is also required to implement `Base`. The two trait\nmethods are unrelated despite having the same name -- thus any type that\nimplements `Derived` will have an implementation of `Derived::method` as well as\nan implementation of `Base::method` and the two are free to have different\nbehavior. Supertraits are not inheritance! Supertraits are a constraint that if\nsome trait is implemented, some other trait must also be implemented.\n\nLet's consider what happens in each of the two methods called from `main`.\n\n- `dynamic_dispatch(&BothTraits)`\n\n    The argument `x` is a reference to the trait object type `dyn Base`. A\n    _trait object_ is a little shim generated by the compiler that implements\n    the trait with the same name by forwarding all trait method calls to trait\n    methods of whatever type the trait object was created from. The forwarding\n    is done by reading from a table of function pointers contained within the\n    trait object.\n\n    ```rust\n    // Generated by the compiler.\n    //\n    // This is an implementation of the trait `Base` for the\n    // trait object type `dyn Base`, which you can think of as\n    // a struct containing function pointers.\n    impl Base for (dyn Base) {\n        fn method(&self) {\n            /*\n            Some automatically generated implementation detail\n            that ends up calling the right type's impl of the\n            trait method Base::method.\n            */\n        }\n    }\n    ```\n\n    In the quiz code, `x.method()` is a call to this automatically generated\n    method whose fully qualified name is `<dyn Base as Base>::method`. Since `x`\n    was obtained by converting a `BothTraits` to `dyn Base`, the automatically\n    generated implementation detail will wind up forwarding to `<BothTraits as\n    Base>::method` which prints `1`.\n\n    Hopefully it's clear from all of this that nothing here has anything to do\n    with the unrelated trait method `Derived::method` defined by `BothTraits`.\n    Especially notice that `x.method()` cannot be a call to `Derived::method`\n    because `x` is of type `dyn Base` and there is no implementation of\n    `Derived` for `dyn Base`.\n\n- `static_dispatch(BothTraits)`\n\n    At compile time we know that `x.method()` is a call to `<T as\n    Base>::method`. Type inference within generic functions in Rust happens\n    independently of any concrete instantiation of the generic function i.e.\n    before we know what `T` may be, other than the fact that it implements\n    `Base`. Thus no inherent method on the concrete type `T` or any other trait\n    method may affect what method `x.method()` is calling. By the time that `T`\n    is decided, it has already been determined that `x.method()` is calling `<T\n    as Base>::method`.\n\n    The generic function is instantiated with `T` equal to `BothTraits` so this\n    is going to call `<BothTraits as Base>::method` which prints `1`.\n\nIf you are familiar with C++, the behavior of this code in Rust is _different_\nfrom the behavior of superficially analogous C++ code. In C++ the output would\nbe `22` as seen in the following implementation. This highlights the difference\nbetween Rust's traits and supertraits vs C++'s inheritance.\n\n```cpp\n#include <iostream>\n\nstruct Base {\n    virtual void method() const {\n        std::cout << \"1\";\n    }\n};\n\nstruct Derived: Base {\n    void method() const {\n        std::cout << \"2\";\n    }\n};\n\nvoid dynamic_dispatch(const Base &x) {\n    x.method();\n}\n\ntemplate <typename T>\nvoid static_dispatch(const T x) {\n    x.method();\n}\n\nint main() {\n    dynamic_dispatch(Derived{});\n    static_dispatch(Derived{});\n}\n```",
    "hint": "`Base::method` and `Derived::method` happen to have the same name but are\notherwise unrelated methods. One does not override the other."
  },
  {
    "id": "028",
    "title": "underscore-prefix",
    "codeSnippet": "struct Guard;\n\nimpl Drop for Guard {\n    fn drop(&mut self) {\n        print!(\"1\");\n    }\n}\n\nfn main() {\n    let _guard = Guard;\n    print!(\"3\");\n    let _ = Guard;\n    print!(\"2\");\n}\n",
    "currentIndex": 0,
    "difficulty": 1,
    "answer": "3121",
    "explanation": "The program prints `3121`. That is, the `Drop` impl for `let _guard = Guard`\nruns at the end of main but the `Drop` impl for `let _ = Guard` runs right away.\n\nIn general, a value is dropped when it no longer has an owner. The variable\n`_guard` owns the first value of type `Guard` and remains in scope until the end\nof main. The `_` is not a variable but a wildcard pattern that binds nothing;\nsince no variables are bound on this line, there is no variable to be the owner\nof the second value of type `Guard` and that value is dropped on the same line.\n\nThis distinction between the underscore pattern vs variables with a leading\nunderscore is incredibly important to remember when working with lock guards in\nunsafe code.\n\n    use std::sync::Mutex;\n\n    static MUTEX: Mutex<()> = Mutex::new(());\n\n    /// MUTEX must be held when accessing this value.\n    static mut VALUE: usize = 0;\n\n    fn main() {\n        let _guard = MUTEX.lock().unwrap();\n        unsafe {\n            VALUE += 1;\n        }\n    }\n\nIf this code were to use `let _ = MUTEX.lock().unwrap()` then the mutex guard\nwould be dropped immediately, releasing the mutex and failing to guard the\naccess of `VALUE`.",
    "hint": "A value is dropped when it no longer has an owner."
  },
  {
    "id": "029",
    "title": "tuple-trailing-commas",
    "codeSnippet": "trait Trait {\n    fn p(&self);\n}\n\nimpl Trait for (u32) {\n    fn p(&self) { print!(\"1\"); }\n}\n\nimpl Trait for (i32,) {\n    fn p(&self) { print!(\"2\"); }\n}\n\nimpl Trait for (u32, u32) {\n    fn p(&self) { print!(\"3\"); }\n}\n\nimpl Trait for (i32, i32,) {\n    fn p(&self) { print!(\"4\"); }\n}\n\nfn main() {\n    (0).p();\n    (0,).p();\n    (0, 0).p();\n    (0, 0,).p();\n}\n",
    "currentIndex": 0,
    "difficulty": 1,
    "answer": "1244",
    "explanation": "The trailing comma is required in the case of a 1-tuple, `(0,)`, because it\ndisambiguates it from `(0)` which is identical to `0`. However, for larger\ntuples, it is entirely optional: `(i32)` is a distinct type from `(i32,)`, but\n`(i32, i32)` and `(i32, i32,)` are the same.\n\nAn integral literal `0` can be inferred to be any integer type, but defaults to\n`i32` if insufficient type information is available. `(0)` is inferred to be a\n`u32` and `(0,)` is inferred to be a `(i32,)` because those are respectively the\nonly integral and 1-tuple types with an implementation for `Trait`.\n\nSince `(0, 0)` and `(0, 0,)` have the same type, the output of their `p` methods\nmust be the same, but Rust needs to somehow choose between the two possible\nimplementations of `Trait`, namely `(u32, u32)` and `(i32, i32)`. Since `i32` is\nthe default integral type, `(i32, i32)` is chosen in both cases.",
    "hint": "A value in parentheses does not have the same type as a 1-tuple."
  },
  {
    "id": "030",
    "title": "clone-pointers",
    "codeSnippet": "use std::rc::Rc;\n\nstruct A;\n\nfn p<X>(x: X) {\n    match std::mem::size_of::<X>() {\n        0 => print!(\"0\"),\n        _ => print!(\"1\"),\n    }\n}\n\nfn main() {\n    let a = &A;\n    p(a);\n    p(a.clone());\n    \n    let b = &();\n    p(b);\n    p(b.clone());\n    \n    let c = Rc::new(());\n    p(Rc::clone(&c));\n    p(c.clone());\n}\n",
    "currentIndex": 0,
    "difficulty": 1,
    "answer": "111011",
    "explanation": "Both of our non-reference types, `()` and `A`, are zero-sized types (ZST). The\nfunction `p<X>` will print `0` if it is passed a value of type `X = ()` or `X =\nA`, and it will print `1` if passed a reference `X = &()` or `X = &A` regardless\nof exactly how big pointers happen to be.\n\n`p(a)` invokes `p` with `X = &A` because the argument `a` is of type `&A`; this\nprints `1`.\n\nOn the next line, if `A` implemented `Clone` then `a.clone()` would be a call to\nthat impl. But since it doesn't, the compiler finds another applicable impl\nwhich is the implementation of `Clone` for references `&T` -- so concretely the\nclone call is calling the impl of `Clone` for `&A` which turns a `&&A` into a\n`&A` by simply duplicating the reference. We get another call to `p` with `X =\n&A` printing `1`. The impl of `Clone` for references is useful in practice when\na struct containing a reference wants to derive `Clone`, but as seen here it can\nsometimes kick in unexpectedly.\n\nThe type `()` _does_ implement `Clone` so `b.clone()` invokes that impl and\nproduces `()`. The implementation of `Clone` for `&()` would also be applicable\nas happened in the case of `A`, but the compiler prefers calling the trait impl\nfor `()` which converts `&()` to `()` over the trait impl for `&()` which\nconverts `&&()` to `&()` because the former is the one that requires fewer\nimplicit references or dereferences inserted by the trait solver. In the call to\n`b.clone()`, `b` is of type `&()` which exactly matches the argument of the impl\n`Clone` for `()`, while in order to obtain a `&&()` to pass as argument to the\nimpl `Clone` for `&()` the trait solver would need to insert an additional layer\nof referencing implicitly -- effectively computing `(&b).clone()`.\n\nWhat we get is `p(b)` calling `p` with `X = &()` and `p(b.clone())` calling `p`\nwith `X = ()`. Together these print `10`.\n\nFinally in the `Rc` case, both calls to `p` are with `X = Rc<()>` which is\nnon-zero sized. It is considered idiomatic to clone a `Rc` using `Rc::clone(&c)`\ninstead of `c.clone()` because it makes it apparent that this is a reference\ncount bump rather than cloning underlying data, but ultimately both refer to the\nsame function. To call the `clone` method of a value inside a `Rc`, you would\nneed to dereference it first: `(*c).clone()`.",
    "hint": "Immutable pointers `&T` and `Rc<T>` implement `Clone` even if `T` doesn't."
  },
  {
    "id": "031",
    "title": "method-lookup",
    "codeSnippet": "trait Or {\n    fn f(self);\n}\n\nstruct T;\n\nimpl Or for &T {\n    fn f(self) {\n        print!(\"1\");\n    }\n}\n\nimpl Or for &&&&T {\n    fn f(self) {\n        print!(\"2\");\n    }\n}\n\nfn main() {\n    let t = T;\n    let wt = &T;\n    let wwt = &&T;\n    let wwwt = &&&T;\n    let wwwwt = &&&&T;\n    let wwwwwt = &&&&&T;\n    t.f();\n    wt.f();\n    wwt.f();\n    wwwt.f();\n    wwwwt.f();\n    wwwwwt.f();\n}\n",
    "currentIndex": 0,
    "difficulty": 2,
    "answer": "111222",
    "explanation": "The [Reference][ref] describes Rust's method lookup order. The relevant\nparagraph is:\n> Obtain [the candidate receiver type] by repeatedly dereferencing the receiver\n> expression's type, adding each type encountered to the list, then finally\n> attempting an unsized coercion at the end, and adding the result type if that\n> is successful. Then, for each candidate `T`, add `&T` and `&mut T` to the\n> list immediately after `T`.\n\nApplying these rules to the given examples, we have:\n* `t.f()`: We try to find a function `f` defined on the type `T`, but there is\n  none. Next, we search the type `&T`, and find the first implementation of the\n  `Or` trait, and we are done. Upon invocation, the resolved call prints `1`.\n* `wt.f()`: We search for a function `f` defined on `&T`, which immediately\n  succeeds. Upon invocation, the function prints `1`.\n* `wwt.f()`: The search order is `&&T` -> `&&&T` -> `&mut &&T` -> `&T`, and\n  we're done. Upon invocation, the function prints `1`.\n* `wwwt.f()`: `&&&T` -> `&&&&T`. This prints `2`.\n* `wwwwt.f()`: `&&&&T`. This prints `2`.\n* `wwwwwt.f()`: `&&&&&T` -> `&&&&&&T` -> `&mut &&&&&T` -> `&&&&T`. This prints\n  `2`.\n\n[ref]: https://doc.rust-lang.org/reference/expressions/method-call-expr.html",
    "hint": "During a method lookup, Rust automatically derefences and borrows the receiver\nin a well-defined order until it finds the first function with a suitable\nsignature. What is that order?"
  },
  {
    "id": "032",
    "title": "or-pattern-guard",
    "codeSnippet": "fn check(x: i32) -> bool {\n    print!(\"{}\", x);\n    false\n}\n\nfn main() {\n    match (1, 2) {\n        (x, _) | (_, x) if check(x) => {\n            print!(\"3\")\n        }\n        _ => print!(\"4\"),\n    }\n}\n",
    "currentIndex": 0,
    "difficulty": 2,
    "answer": "124",
    "explanation": "This question covers two behaviors of `match` arms and guards.\n\nFirst, whether an `if` guard on a match-arm containing `|` applies to *all*\nalternatives in the match-arm or just to the one it is adjacent to. In the quiz\ncode, does `check(x)` execute at all for `(x, _)` or does it only cover the `(_,\nx)` case? We would expect `1` would get printed if and only if the former is the\ncase. In fact `1` does get printed. A match-arm gets to have at most one `if`\nguard and that guard applies to all the `|`-separated alternatives in the arm.\n\nBut second, this question also covers a kind of \"backtracking\" behavior of\nmatch-arms. After `check(x)` returns false on `(x, _)`, does the whole match-arm\nfail to match at that point or does Rust move on to `(_, x)` and execute the\nguard a second time? We would expect `2` to be printed if and only if the latter\nis the case. In fact `2` does get printed; the guard is being run multiple\ntimes, once per `|`-separated alternative in the match-arm.",
    "hint": "Either way would be confusing in different situations; there isn't a clear right\nbehavior that a hint could help identify. Guess both. :/"
  },
  {
    "id": "033",
    "title": "range-full-method",
    "codeSnippet": "use std::ops::RangeFull;\n\ntrait Trait {\n    fn method(&self) -> fn();\n}\n\nimpl Trait for RangeFull {\n    fn method(&self) -> fn() {\n        print!(\"1\");\n        || print!(\"3\")\n    }\n}\n\nimpl<F: FnOnce() -> T, T> Trait for F {\n    fn method(&self) -> fn() {\n        print!(\"2\");\n        || print!(\"4\")\n    }\n}\n\nfn main() {\n    (|| .. .method())();\n}\n",
    "currentIndex": 0,
    "difficulty": 3,
    "answer": "24",
    "explanation": "The two rational possibilities are `1` or `24`, depending on how the precedence\nof `|| .. .method()` is disambiguated.\n\n- As `|| ((..).method())`, which is a closure whose body invokes our impl of\n  `Trait` on `RangeFull`. In this case `main` would print `1`. It would *not*\n  print `13` because the `fn()` returned from `(..).method()` is never invoked\n  by `main`.\n\n- As `(|| ..).method()`, which is an invocation of our impl of `Trait` on\n  `FnOnce() -> T` where `T` is inferred to be `RangeFull`. In this case `main`\n  would print `24`.\n\nThe latter of those is the correct answer.\n\nWe can achieve the former behavior by explicitly parenthesizing as shown in the\nbullet above.\n\nPartially parenthesizing as `|| (.. .method())` is not sufficient. This results\nin a parse error.\n\n```\nerror: expected one of `)` or `,`, found `.`\n  --> src/main.rs:22:13\n   |\n22 |     (|| (.. .method()))();\n   |            -^ expected one of `)` or `,`\n   |            |\n   |            help: missing `,`\n```\n\nCorrectly handling a quite ambiguous expression like `|| .. .method()` is a\nchallenge for tooling, as seen by the associated bugs in Rustfmt\n([rust-lang/rustfmt#4808]) and Syn ([dtolnay/syn#1019]).\n\n[rust-lang/rustfmt#4808]: https://github.com/rust-lang/rustfmt/issues/4808\n[dtolnay/syn#1019]: https://github.com/dtolnay/syn/issues/1019",
    "hint": "`||` is a closure introducer. `..` is range syntax, normally seen in slicing\noperations like `&s[1..4]` or `&s[..s.len() - 1]`."
  },
  {
    "id": "034",
    "title": "fn-pointer-vs-fn-type",
    "codeSnippet": "fn d<T>(_f: T) {\n    match std::mem::size_of::<T>() {\n        0 => print!(\"0\"),\n        1 => print!(\"1\"),\n        _ => print!(\"2\"),\n    }\n}\n\nfn a<T>(f: fn(T)) {\n    d(f);\n}\n\nfn main() {\n    a(a::<u8>);\n    d(a::<u8>);\n}\n",
    "currentIndex": 0,
    "difficulty": 2,
    "answer": "20",
    "explanation": "The expression `a::<u8>`'s type is a zero-sized type (ZST).\n\nRust's implementation choices around function types are different from nearly\nall other languages, but are an important enabler of many of Rust's\nzero-overhead abstractions. In Rust, every function (or every distinct\ninstantiation of a generic function) has its own unique type. In particular,\neven two functions with the same function signature would have different types.\n\nHaving a unique type for each function allows the type itself to carry the\ninformation of what function will be called, not needing any runtime state such\nas a pointer.\n\nTo understand the optimization advantages of this approach, consider\n`Iterator::map` and the two calls `iter.map(f)` and `iter.map(g)` where `f` and\n`g` are different functions with the same signature. Because `f` and `g` have\ndistinct types, the two `map` calls would produce two different monomorphic\ninstantiations of the generic `map` function, one of which statically calls `f`\nand the other statically calls `g`, as if you had directly written a\nspecial-purpose map implementation specific to each function without the\nabstraction provided by `map`. The generic `map` is thus a zero-overhead\nabstraction. Traditionally in other languages such as C++ or Go, in this\nsituation `f` and `g` would be passed to `map` as a function pointer and there\nwould be just one instantiation of `map`, containing a dynamic dispatch to\nexecute the function call, which is usually going to be slower than statically\ncalling the right function. This performance penalty makes `map` in those\nlanguages not a zero-overhead abstraction.\n\nCurrently in Rust there is no syntax to express the type of a specific function,\nso they are always passed as a generic type parameter with a `FnOnce`, `Fn` or\n`FnMut` bound. In error messages you might see function types appear in the\nform `fn(T) -> U {fn_name}`, but you can't use this syntax in code.\n\nOn the other hand, a function pointer, `fn(T) -> U`, is pointer-sized at\nruntime. Function types can be coerced into function pointers, which can be\nuseful in case you need to defer the choice of function to call until runtime.\n\nIn the quiz code, the first call in `main` coerces `a::<u8>` from a function to\na function pointer (`fn(fn(u8)) {a::<u8>}` to `fn(fn(u8))`) prior to calling\n`d`, so its size would be 8 on a system with 64-bit function pointers. The\nsecond call in `main` does not involve function pointers; `d` is directly called\nwith `T` being the inexpressible type of `a::<u8>`, which is zero-sized.",
    "hint": "The answer would be the same with any other integer type in place of `u8`."
  },
  {
    "id": "035",
    "title": "decl-macro-hygiene",
    "codeSnippet": "macro_rules! x {\n    ($n:expr) => {\n        let a = X($n);\n    };\n}\n\nstruct X(u64);\n\nimpl Drop for X {\n    fn drop(&mut self) {\n        print!(\"{}\", self.0);\n    }\n}\n\nfn main() {\n    let a = X(1);\n    x!(2);\n    print!(\"{}\", a.0);\n}\n",
    "currentIndex": 0,
    "difficulty": 1,
    "answer": "121",
    "explanation": "There are two reasonable paths to an incorrect answer on this question, based on\nyour assumptions around how this macro gets expanded:\n\n1. `let a = X(2);`\n2. `{ let a = X(2); }`\n\nIf the first expansion were right, the macro would introduce a new binding, `a`,\nwhich shadows the `a` already directly assigned in `main`. So the print\nstatement in `main` would execute first, printing `2`, then the variables would\ndrop in reverse order of introduction, printing `2` then `1`, with a final\noutput of `221`.\n\nIf the second expansion were right, the macro would introduce `a` in a nested\nscope, shadowing the already existing `a` only inside of that scope and not\nbeyond it. Since the new `a`'s scope ends before the print statement, its `Drop`\nimpl when going out of scope would be the first print to execute, printing `2`.\nNext the print in `main` would print `1` which is the value of the first `a`,\nand finally `1` again when that value drops at the end of `main`, with final\noutput `211`.\n\nIf you've read about macro hygiene then you might have guessed it would be\nimplemented something like this second option. It's important that internals of\na macro don't interfere coincidentally with variables in scope at the call site,\nand Rust macros mostly do a good job of preventing unintended name collisions.\nHowever, this is not how hygiene is implemented; introducing artificial scopes\naround macro expansions would make them more limited in their usefulness, and\nwouldn't solve a lot of other hygiene problems.\n\nYou can instead imagine hygiene as a way of assigning a color to each mention of\nthe name of a local variable, allowing for there to be multiple distinguishable\nlocal variables in scope simultaneously with the same textual name.\n\n<pre><code>fn main() {\n    let <b style=\"background-color:mediumpurple;color:white\">a</b> = X(1);\n    let <b style=\"background-color:coral;color:white\">a</b> = X(2);\n    print!(\"{}\", <b style=\"background-color:mediumpurple;color:white\">a</b>.0);\n}</code></pre>\n\nSo what's printed is the value of `main`'s identifier\n<code><b style=\"background-color:mediumpurple;color:white\">a</b></code>\nwhich is `1`, then the two values are dropped in reverse order of introduction\nprinting `2` then `1`, and the output of the program is `121`.",
    "hint": "There are some programs for which `cargo expand` produces expanded code that\ncompiles, but behaves differently than the original code with the original macro\nhygiene."
  },
  {
    "id": "036",
    "title": "fnmut-copy",
    "codeSnippet": "fn call(mut f: impl FnMut() + Copy) {\n    f();\n}\n\nfn g(mut f: impl FnMut() + Copy) {\n    f();\n    call(f);\n    f();\n    call(f);\n}\n\nfn main() {\n    let mut i = 0i32;\n    g(move || {\n        i += 1;\n        print!(\"{}\", i);\n    });\n}\n",
    "currentIndex": 0,
    "difficulty": 1,
    "answer": "1223",
    "explanation": "The object passed into `g` is a `FnMut` closure which captures an integer by\nvalue. Effectively it's an unnameable struct containing a single field whose\ntype is `i32`, with a function call operator that takes `&mut self`:\n\n```rust\n#[derive(Copy, Clone)]\npub struct UnnameableClosure {\n    i: i32,\n}\n\nimpl UnnameableClosure {\n    pub fn unnameable_call_operator(&mut self) {\n        self.i += 1;\n        print!(\"{}\", self.i);\n    }\n}\n\nlet mut i = 0i32;\ng(UnnameableClosure { i });\n```\n\nThe behavior of the 4 calls inside `g` is as follows:\n\n- `f()` runs the closure and its by-value captured value of `i` becomes 1.\n\n- `call(f)` makes a **copy** of `f` to become the argument of `call`. The copy\n  gets executed and its `i` becomes 2, but the original closure still holds a\n  value of 1 for its captured `i`. The copy of the closure gets dropped as it\n  goes out of scope at the end of the body of `call`.\n\n- `f()` runs the original closure a second time and its `i` becomes 2.\n\n- `call(f)` copies `f` a second time and executes the copy, its `i` becomes 3.\n\nSince Rust 1.26, closures automatically implement `Clone` if all their captures\nimplement `Clone`, and `Copy` if all the captures implement `Copy`.\n\nIf the `move` keyword were omitted from the quiz code, the compiler-generated\nclosure would capture `i` by mutable reference instead of by value:\n\n```rust\npub struct UnnameableClosure<'a> {\n    i: &'a mut i32,\n}\n```\n\nand there would no longer be a `Copy` impl, because it's incorrect to duplicate\na mutable reference into multiple copies (aliasing xor mutation; this is the\npoint of the borrow checker).\n\nOne recurring source of confusion for Rust beginners is the relationship between\n`move` and non-`move` closures vs `Fn` and `FnMut` and `FnOnce` closures. These\nare two nearly-orthogonal things. As illustrated in the `UnnameableClosure`\npseudocode above, `move` vs non-`move` is about whether the *fields* of the\ncompiler-generated closure struct have the same type as the original captured\nvariable's type, vs are references to the original captured variable's type\n(`i32` vs `&mut i32`, for example). In contrast, `Fn` vs `FnMut` vs `FnOnce` is\nabout whether the *call method* of the compiler-generated closure struct has a\nreceiver which is `&self` vs `&mut self` vs `self`.",
    "hint": "The variable `i` is captured by value in the compiler-generated closure object."
  },
  {
    "id": "037",
    "title": "lifetime-extension",
    "codeSnippet": "struct Drop0;\nimpl Drop for Drop0 {\n    fn drop(&mut self) {\n        print!(\"0\");\n    }\n}\n\nfn main() {\n    {\n        let _ = &Drop0;\n        print!(\"1\");\n    }\n    {\n        _ = &Drop0;\n        print!(\"1\");\n    }\n}\n",
    "currentIndex": 0,
    "difficulty": 2,
    "answer": "1001",
    "explanation": "In both cases, since we don't assign the `Drop0` instance to a variable, it is a\n[temporary].\n\nIn `let` statements, [temporary lifetime extension][tle] takes place and extends\nthe temporary's lifetime until the end of the block, there it is dropped. So `1`\nis printed first, and then the `Drop0` is dropped and `0` is printed.\n\nIn assignments, however (`_ = ` is a [destructuring assignment][des_assign]\nexpression), there is no temporary lifetime extension, and temporaries are\ndropped at the end of the statement. So, `0` is printed first then `1`.\n\nThis behavior also means that if we would try to use the value after the\nassignment, the compiler will disallow this with a borrow checker error, as the\nvalue was already dropped.\n\n[temporary]: https://doc.rust-lang.org/stable/reference/expressions.html#temporaries\n[tle]: https://doc.rust-lang.org/stable/reference/destructors.html#temporary-lifetime-extension\n[des_assign]: https://rust-lang.github.io/rfcs/2909-destructuring-assignment.html",
    "hint": "`let` is a statement, while assignment is an expression."
  }
]